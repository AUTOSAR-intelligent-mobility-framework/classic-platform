/* 
 *
 *  The Irq_IsrTypeTable does not exist any more.
 *  The Irq_VectorTable is now a pure function table (not mixed pcb and functions )
 *  The PPC interrupt handling is a bit faster.
 * 
 *
 *   New files for arch offsets? 
 *   Bypassed Irq_Entry()...
 *  TODO:
 *    Move pre/post hooks into swap code?
 *
 *
 * IMPLEMENTATION NOTES
 *  OPT: For ISR1 (interrupts always off) the there is no need to save r13-r31 since
 *  it will be saved by the C-function. 
 */
	
/*
 * Small assembler school
 *  Compare imm(32-bit)
 *   $ cmpwi rA,100
 *  Extract bits and right adjust
 *   $ extrwi rA,rS,n,b  ( n-number of bits, b- startbit )
 *  Use of @ha,@h,@l. Use @ha for arithmetic instructions to compensate for sign.
 *  To cause less confusion use load and logical instructions instead of arithmetic ones.
 *   $ lis r3,0x8000@h    
 *   $ ori r3,r3,0x08000@l
 *  is the same as 
 *   $ addis r3,0x8000@ha    
 *   $ addi r3,r3,0x08000@l
 *
 * Note!
 * The offset's (d or D)for SPE instructions are ridiculously low.
 * Normally you have 16-bits offset, but when using spe load and store
 * you can use only 8-bit.
*/


/* ----------------------------[includes]------------------------------------*/
#define _ASSEMBLER_
#include "asm_ppc.h"
#include "arch_offset.h"
#include "asm_offset.h"
#include "arch_stack.h"

// #include "asm_book_e.h"
.extern os_intc_pcb_tbl
.extern os_intc_types_tbl
.extern os_sys
.extern Os_ArchPanic

/* ----------------------------[private define]------------------------------*/

#define INTC_IACKR_PRC0		0xfff48010  /* MPC551x CPU #0  */ 
#define INTC_EOIR_PRC0		0xfff48018  /* MPC551x CPU #0  */
#define INTC_IACKR			0xfff48010  /* MPC555x         */
#define INTC_EOIR			0xfff48018  /* MPC555x         */
#define INTC_SSCIR0			0xfff48020

/* ----------------------------[private macro]-------------------------------*/

#define	LOCK()			wrteei	0
#define	UNLOCK()		wrteei	1

#define EXC_TABLE_CODE(_exc_nr) 	\
	stwu	sp,-EXC_FRM_SIZE(sp); 	\
	stw		r3,EXC_FRM_R3(sp);		\
	li	    r3,_exc_nr;				\
	b		handleException			

#if ISR_FRM_PATTERN!=FUNC_FRM_PATTERN
#error Context pattern must be in the same place
#endif

/* ----------------------------[private typedef]-----------------------------*/
/* ----------------------------[private function prototypes]-----------------*/
/* ----------------------------[private variables]---------------------------*/
/* ----------------------------[private functions]---------------------------*/
/* ----------------------------[public functions]----------------------------*/

.extern Os_Isr

.global Os_ArchSwapContextTo
.global Os_ArchSwapContext
.global Os_ArchSetSpAndCall
.section .text

Os_ArchSetSpAndCall:
		mr r1,r3
		mtlr r4
		blr

/**
 * void Os_ArchSwapContext(pcb_t *old, pcb_t *new )
 *
 * Saves a function context on current stack, pops a new one from new context
 *
 * r3 - pcb for old task
 * r4 - pcb for new task
 *
 */
Os_ArchSwapContext:
	stwu 	sp,-FUNC_FRM_SIZE(sp)
	mflr 	r0
	stw		r0,FUNC_FRM_LR(sp)
	mfcr	r0
	stw		r0,FUNC_FRM_CR(sp)
	
	/* Save context indicator */
	li		r0,FUNC_PATTERN
	stw		r0,FUNC_FRM_PATTERN(sp)
	
	/* Save registers preserved by function call */
	stw		r14, FUNC_FRM_R14(sp)
	stw		r15, FUNC_FRM_R15(sp)
	stw		r16, FUNC_FRM_R16(sp)
	stw		r17, FUNC_FRM_R17(sp)
	stw		r18, FUNC_FRM_R18(sp)
	stw		r19, FUNC_FRM_R19(sp)
	stw		r20, FUNC_FRM_R20(sp)
	stw		r21, FUNC_FRM_R21(sp)
	stw		r22, FUNC_FRM_R22(sp)
	stw		r23, FUNC_FRM_R23(sp)
	stw		r24, FUNC_FRM_R24(sp)
	stw		r25, FUNC_FRM_R25(sp)
	stw		r26, FUNC_FRM_R26(sp)
	stw		r27, FUNC_FRM_R27(sp)
	stw		r28, FUNC_FRM_R28(sp)
	stw		r29, FUNC_FRM_R29(sp)
	stw		r30, FUNC_FRM_R30(sp)
	stw		r31, FUNC_FRM_R31(sp)


	/* Save stack ptr... */
	stw		sp,PCB_STACK_CURR_P(r3)

	/* TODO: Call Os_PretaskHook()? */ 
	
	/* 	Flow down  */
	
/**
 * void Os_ArchSwapContextTo( NULL, pcb_t *new )
 * r3 - always NULL
 * r4 - The pcb to switch to.
 */ 	
Os_ArchSwapContextTo:
	/* Get stack for new task */
	lwz		sp,PCB_STACK_CURR_P(r4)

	/* Set new current task */
	LOAD_ADDR_32(3,os_sys)
	stw		r4,SYS_CURR_PCB_P(r3)

	/* Restore C context */
	lwz     r0,FUNC_FRM_CR(sp)
    mtcr    r0
    lwz     r0,FUNC_FRM_LR (sp)
    mtlr    r0

	/* Get the context type */
	lwz		r0, FUNC_FRM_PATTERN(sp)
	cmpli	0, r0, FUNC_PATTERN
	beq+	restoreFuncContext
	cmpli	0, r0,ISR_PATTERN
	beq+ 	restoreIsrContext
	li 		r3, OS_ERR_BAD_CONTEXT
	b		Os_ArchPanic

restoreFuncContext:
	lwz		r14, FUNC_FRM_R14(sp)
	lwz		r15, FUNC_FRM_R15(sp)
	lwz		r16, FUNC_FRM_R16(sp)
	lwz		r17, FUNC_FRM_R17(sp)
	lwz		r18, FUNC_FRM_R18(sp)
	lwz		r19, FUNC_FRM_R19(sp)
	lwz		r20, FUNC_FRM_R20(sp)
	lwz		r21, FUNC_FRM_R21(sp)
	lwz		r22, FUNC_FRM_R22(sp)
	lwz		r23, FUNC_FRM_R23(sp)
	lwz		r24, FUNC_FRM_R24(sp)
	lwz		r25, FUNC_FRM_R25(sp)
	lwz		r26, FUNC_FRM_R26(sp)
	lwz		r27, FUNC_FRM_R27(sp)
	lwz		r28, FUNC_FRM_R28(sp)
	lwz		r29, FUNC_FRM_R29(sp)
	lwz		r30, FUNC_FRM_R30(sp)
	lwz		r31, FUNC_FRM_R31(sp)
	addi 	sp,sp,(FUNC_FRM_SIZE)
	
	/* TODO: Call Os_PosttaskHook()? */
	
	blr


/**
 * External input exception handlers 
 */ 
		.global exception_IVOR4
		.global restoreIsrContext
		.balign 16
exception_IVOR4:

	/* Save the exception frame */
	stwu	sp,-EXC_FRM_SIZE(sp)

	stw  	r3,EXC_FRM_R3(sp)

	mfsrr0 	r3
	stw 	r3, EXC_FRM_SRR0(sp)
	mfsrr1 	r3
	stw 	r3, EXC_FRM_SRR1(sp)

	mfcr 	r3
	stw 	r3, EXC_FRM_CR(sp)	
	mfxer 	r3 
	stw 	r3, EXC_FRM_XER(sp)
	mfctr 	r3
	stw 	r3, EXC_FRM_CTR(sp)
	mflr 	r3
	stw 	r3, EXC_FRM_LR(sp)	
	
	li		r3,4
	stw 	r3, EXC_FRM_VECTOR(sp)
	
	/* Save the ISR frame */
	addi 	sp,sp,-ISR_FRM_SIZE
	stw		r0, ISR_FRM_R0(sp)
	stw		r4, ISR_FRM_R4(sp)
	stw		r5, ISR_FRM_R5(sp)
	stw		r6, ISR_FRM_R6(sp)
	stw		r7, ISR_FRM_R7(sp)
	stw		r8, ISR_FRM_R8(sp)
	stw		r9, ISR_FRM_R9(sp)
	stw		r10, ISR_FRM_R10(sp)
	stw		r11, ISR_FRM_R11(sp)
	stw		r12, ISR_FRM_R12(sp)
	stw		r14, ISR_FRM_R14(sp)
	stw		r15, ISR_FRM_R15(sp)
	stw		r16, ISR_FRM_R16(sp)
	stw		r17, ISR_FRM_R17(sp)
	stw		r18, ISR_FRM_R18(sp)
	stw		r19, ISR_FRM_R19(sp)
	stw		r20, ISR_FRM_R20(sp)
	stw		r21, ISR_FRM_R21(sp)
	stw		r22, ISR_FRM_R22(sp)
	stw		r23, ISR_FRM_R23(sp)
	stw		r24, ISR_FRM_R24(sp)
	stw		r25, ISR_FRM_R25(sp)
	stw		r26, ISR_FRM_R26(sp)
	stw		r27, ISR_FRM_R27(sp)
	stw		r28, ISR_FRM_R28(sp)
	stw		r29, ISR_FRM_R29(sp)
	stw		r30, ISR_FRM_R30(sp)
	stw		r31, ISR_FRM_R31(sp)

	
	li 		r3,ISR_PATTERN
	stw		r3,ISR_FRM_PATTERN(sp)
	// Save the stack so it later can be saved in the pcb	
	mr		r4,sp			
	
	// Switch to interrupt stack if at depth 0
	// Load the value os_sys.int_nest_cnt
	LOAD_IND_32(r3,os_sys+SYS_INT_NEST_CNT)
	cmpli	0,r3,0
	bne-	on_int_stack

	// Load the interrupt stack
	LOAD_IND_32(r3,os_sys+SYS_INT_STACK)

on_int_stack:

#if defined(CFG_MPC5516)
	lis r6, INTC_IACKR_PRC0@ha
	lwz r6, INTC_IACKR_PRC0@l(r6)
#elif defined(CFG_MPC5554) || defined(CFG_MPC5567)
	lis r6, INTC_IACKR@ha 
	lwz r6, INTC_IACKR@l(r6)
#endif
	/* Check for 0 entry */
	mr		r5,r6
	extrwi  r5,r5,9,21
	cmpli 	0,r5,0
	bne+	vectorOk
	/* The entry was 0, call panic */
	li 		r3,OS_ERR_SPURIOUS_INTERRUPT
	li 		r4, 0
	mr		r5,r1
	b 		Os_ArchPanic
	
vectorOk:
	/* Check for soft INT */
	cmpli 	0,r5,7
	bgt		noSoftInt
	/* Clear soft interrupt */
	li		r0,1	
	lis		r3, INTC_SSCIR0@h
	ori		r3, r3, INTC_SSCIR0@l
	stbx	r0,r5,r3			
	
noSoftInt:	

	lis   r3, Os_Isr@h
    ori   r3, r3,Os_Isr@l
    mtlr  r3
	mr    r3,r4  		/* "old" stack as arg1 */
    lwz   r4, 0x0(r6) 	/* Read the address from the for function/pcb entry */
    blrl		 		/* Call the entry */

	/* Notes!
	 * The OS interrupt is ACK'd in Os_Isr(). For ISR1 it needs to call Irq_EOI()
	 */
	 
	/* Irq_Entry have returned the stack we shall use */
	mr 		sp,r3

	/* Restore */
restoreIsrContext:		
	lwz		r0, ISR_FRM_R0(sp)
	lwz		r4, ISR_FRM_R4(sp)
	lwz		r5, ISR_FRM_R5(sp)
	lwz		r6, ISR_FRM_R6(sp)
	lwz		r7, ISR_FRM_R7(sp)
	lwz		r8, ISR_FRM_R8(sp)
	lwz		r9, ISR_FRM_R9(sp)
	lwz		r10, ISR_FRM_R10(sp)
	lwz		r11, ISR_FRM_R11(sp)
	lwz		r12, ISR_FRM_R12(sp)
	lwz		r14, ISR_FRM_R14(sp)
	lwz		r15, ISR_FRM_R15(sp)
	lwz		r16, ISR_FRM_R16(sp)
	lwz		r17, ISR_FRM_R17(sp)
	lwz		r18, ISR_FRM_R18(sp)
	lwz		r19, ISR_FRM_R19(sp)
	lwz		r20, ISR_FRM_R20(sp)
	lwz		r21, ISR_FRM_R21(sp)
	lwz		r22, ISR_FRM_R22(sp)
	lwz		r23, ISR_FRM_R23(sp)
	lwz		r24, ISR_FRM_R24(sp)
	lwz		r25, ISR_FRM_R25(sp)
	lwz		r26, ISR_FRM_R26(sp)
	lwz		r27, ISR_FRM_R27(sp)
	lwz		r28, ISR_FRM_R28(sp)
	lwz		r29, ISR_FRM_R29(sp)
	lwz		r30, ISR_FRM_R30(sp)
	lwz		r31, ISR_FRM_R31(sp)
	
	/* back to the exception frame */
	addi 	sp,sp,ISR_FRM_SIZE
	
	lwz 	r3, EXC_FRM_LR(sp)
	mtlr 	r3
	lwz	 	r3, EXC_FRM_CTR(sp)
	mtctr 	r3
	lwz 	r3, EXC_FRM_XER(sp)
	mtxer 	r3
	lwz 	r3, EXC_FRM_CR(sp)
	mtcr	r3
	lwz 	r3, EXC_FRM_SRR0(sp)
	mtsrr0 	r3
	lwz 	r3, EXC_FRM_SRR1(sp)
	mtsrr1 	r3
	lwz 	r3, EXC_FRM_R3(sp)
	addi	sp,sp,EXC_FRM_SIZE
	rfi



/**
 * Decrementer exception. It just triggers soft interrupt 7.
 *
 */
exception_IVOR10:
    stwu  	r3,-8(sp)
    stw   	r4,4(sp)

    /* ack dec int */
    lis 	r3,0x0800
    mtspr   SPR_TSR,r3

    /* Set soft int */
    li  	r4,2
    lis     r3, INTC_SSCIR7@ha
    stb     r4, INTC_SSCIR7@l(r3)

    lwz     r3,0(sp)
    lwz     r4,4(sp)
    addi  	sp,sp,8
    rfi





/* Getting here means that the exception stack is started with:
 * sp - saved
 * r3 - saved and contains the exception number 
 */
handleException:
	b  handleException		
	
.section ".exception_tbl","ax"
.balign 0x1000
.global exception_tbl

exception_tbl:
	EXC_TABLE_CODE(0)
	EXC_TABLE_CODE(1)
	EXC_TABLE_CODE(2)
	EXC_TABLE_CODE(3)
    b      exception_IVOR4
    .skip   +0xc
	EXC_TABLE_CODE(5)
	EXC_TABLE_CODE(6)
	EXC_TABLE_CODE(7)
	EXC_TABLE_CODE(8)
	EXC_TABLE_CODE(9)
    b	   exception_IVOR10
    .skip   +0xc
	EXC_TABLE_CODE(11)
	EXC_TABLE_CODE(12)
	EXC_TABLE_CODE(13)
	EXC_TABLE_CODE(14)



// ------------------------------------------------------------------






